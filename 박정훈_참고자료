5ê°œ ì¹´í…Œê³ ë¦¬ Ã— 100ê±´ = ì´ 500ê±´ì˜ í•©ì„± ë°ì´í„°ë¥¼ ìƒì„±í–ˆìŠµë‹ˆë‹¤.
ìƒì„± ê²°ê³¼ ìš”ì•½
ì¹´í…Œê³ ë¦¬
ê±´ìˆ˜
í‰ê·  ì£¼ë¬¸ê¸ˆì•¡
ë°˜ì°¬/ê¹€ì¹˜ë¥˜
100ê±´
70,610ì›
ë†ì‚°ë¬¼
100ê±´
145,860ì›
ìˆ˜ì‚°ë¬¼/ì “ê°ˆ
100ê±´
85,000ì›
ì¶•ì‚°ë¬¼
100ê±´
241,800ì›
ê°€ê³µì‹í’ˆ/ë–¡/í•œê³¼
100ê±´
153,220ì›

ë°˜ì˜ëœ ë¹„ì •í˜• íŒ¨í„´
ê° ë°ì´í„°ì—ëŠ” ì‹¤ì œ ì¹´ì¹´ì˜¤í†¡ ì£¼ë¬¸ì—ì„œ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ë¹„ì •í˜• ìš”ì†Œê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤:
1. ìƒí’ˆëª… ë³€í˜•: ë°°ì¶”ê¹€ì¹˜ â†’ "ë°°ê¹€ì¹˜", "í¬ê¸°ê¹€ì¹˜", "ë§›ê¹€ì¹˜" ë“±
2. ìˆ˜ëŸ‰/ìš©ëŸ‰ í‘œí˜„: 1kg â†’ "1í‚¤ë¡œ", "í•œí‚¤ë¡œ", "1í‚¬ë¡œ", "1K" ë“±
3. ë©”ì‹œì§€ í˜•ì‹:
ì •í˜•ì— ê°€ê¹Œìš´ ì¤„ë°”ê¿ˆ í˜•ì‹
í•œ ì¤„ë¡œ ì­‰ ì´ì–´ì“°ê¸°
ìˆœì„œê°€ ë’¤ë°”ë€ í˜•íƒœ
ì´ëª¨í‹°ì½˜ í¬í•¨ (ğŸ, ğŸ¦, ğŸ¥© ë“±)
ë°˜ë§/ì¡´ëŒ“ë§ í˜¼ìš©
4. ì „í™”ë²ˆí˜¸ ë³€í˜•: "010-1234-5678", "ê³µì¼ê³µ12345678", "01012345678" ë“±
5. ì¬ì£¼ë¬¸ íŒ¨í„´: "ì €ë²ˆì— ì£¼ë¬¸í•œ â—‹â—‹ì¸ë°ìš” ì£¼ì†Œë™ì¼"

íŒŒì¼ ì„¤ëª…:
synthetic_orders.xlsx: í•™ìŠµìš© ì—‘ì…€ (ì›ë³¸ë©”ì‹œì§€ + ì •ë‹µ ë ˆì´ë¸”)
synthetic_orders.json: ì „ì²´ ë°ì´í„° (í”„ë¡œê·¸ë˜ë°ìš©)
seller_guides.md: 5ê°œ ì¹´í…Œê³ ë¦¬ íŒë§¤ì ì£¼ë¬¸ ê°€ì´ë“œ




ì‹œìŠ¤í…œ ê°œìš”
ì „ì²´ ì•„í‚¤í…ì²˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ì£¼ë¬¸ ìˆ˜ì§‘ ë ˆì´ì–´                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ì¹´ì¹´ì˜¤í†¡     â”‚    ë°´ë“œ     â”‚  ì¸ìŠ¤íƒ€ê·¸ë¨  â”‚   ì»¤ë®¤ë‹ˆí‹°   â”‚   SMS/ë¬¸ì    â”‚
â”‚  ì±„ë„/ì˜¤í”ˆì±— â”‚   ëŒ“ê¸€/DM   â”‚   DM/ëŒ“ê¸€   â”‚   ëŒ“ê¸€/ìª½ì§€  â”‚               â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚             â”‚             â”‚             â”‚              â”‚
       â–¼             â–¼             â–¼             â–¼              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ë©”ì‹œì§€ í†µí•© ìˆ˜ì§‘ê¸° (Message Aggregator)               â”‚
â”‚  - Kafka/RabbitMQ ê¸°ë°˜ ë©”ì‹œì§€ í                                         â”‚
â”‚  - ì±„ë„ë³„ ì»¤ë„¥í„° (API, ì›¹í›…, í¬ë¡¤ë§)                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ (Preprocessing)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚ í…ìŠ¤íŠ¸    â”‚â†’â”‚ ì´ë¯¸ì§€    â”‚â†’â”‚ ìŒì„±      â”‚â†’â”‚ í†µí•©      â”‚            â”‚
â”‚  â”‚ ì •ê·œí™”    â”‚  â”‚ OCR ì²˜ë¦¬  â”‚  â”‚ STT ë³€í™˜  â”‚  â”‚ ì •ì œ      â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LLM ê¸°ë°˜ ì •í˜•í™” ì—”ì§„ (Core Engine)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Multi-Agent Orchestrator                           â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚   â”‚
â”‚  â”‚  â”‚ ì˜ë„    â”‚  â”‚ ì—”í‹°í‹°  â”‚  â”‚ ì»¨í…ìŠ¤íŠ¸â”‚  â”‚ ê²€ì¦    â”‚           â”‚   â”‚
â”‚  â”‚  â”‚ ë¶„ë¥˜ê¸°  â”‚  â”‚ ì¶”ì¶œê¸°  â”‚  â”‚ í•´ì„ê¸°  â”‚  â”‚ Agent   â”‚           â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ ìƒí’ˆ ì¹´íƒˆë¡œê·¸   â”‚  â”‚ ê³ ê° DB        â”‚  â”‚ ì£¼ë¬¸ íˆìŠ¤í† ë¦¬   â”‚        â”‚
â”‚  â”‚ Vector Store   â”‚  â”‚ (ë‹¨ê³¨ ì •ë³´)    â”‚  â”‚ RAG Store      â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ê²€ì¦ ë° í™•ì¸ ë ˆì´ì–´ (Validation)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ ì‹ ë¢°ë„ í‰ê°€   â”‚â†’â”‚ ë¶ˆí™•ì‹¤ í•­ëª©   â”‚â†’â”‚ íŒë§¤ì í™•ì¸   â”‚              â”‚
â”‚  â”‚ (Confidence)  â”‚  â”‚ í”Œë˜ê·¸ ì²˜ë¦¬   â”‚  â”‚ ëŒ€ì‹œë³´ë“œ      â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì¶œë ¥ ë° ìë™í™” ë ˆì´ì–´ (Output)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ ì—‘ì…€/     â”‚  â”‚ ì¬ê³ ê´€ë¦¬  â”‚  â”‚ ë°°ì†¡ë¼ë²¨  â”‚  â”‚ íšŒê³„/ì •ì‚° â”‚          â”‚
â”‚  â”‚ êµ¬ê¸€ì‹œíŠ¸  â”‚  â”‚ ì‹œìŠ¤í…œ    â”‚  â”‚ ìë™ìƒì„±  â”‚  â”‚ ì—°ë™      â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1ë‹¨ê³„: ë©”ì‹œì§€ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
1.1 ì¹´ì¹´ì˜¤í†¡ ë©”ì‹œì§€ ìˆ˜ì§‘
python# kakao_collector.py
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, List
import asyncio

@dataclass
class RawMessage:
    """ìˆ˜ì§‘ëœ ì›ë³¸ ë©”ì‹œì§€ êµ¬ì¡°"""
    message_id: str
    channel: str  # 'kakao', 'band', 'instagram', 'sms'
    sender_id: str
    sender_name: str
    content: str
    attachments: List[str]  # ì´ë¯¸ì§€, íŒŒì¼ URL
    timestamp: datetime
    context_messages: List[str]  # ì´ì „ ëŒ€í™” ë§¥ë½
    
class KakaoChannelCollector:
    """
    ì¹´ì¹´ì˜¤í†¡ ì±„ë„ ë©”ì‹œì§€ ìˆ˜ì§‘ê¸°
    - ì¹´ì¹´ì˜¤ ë¹„ì¦ˆë‹ˆìŠ¤ API í™œìš©
    - ì›¹í›… ê¸°ë°˜ ì‹¤ì‹œê°„ ìˆ˜ì‹ 
    """
    
    def __init__(self, channel_id: str, api_key: str):
        self.channel_id = channel_id
        self.api_key = api_key
        self.message_queue = asyncio.Queue()
    
    async def webhook_handler(self, payload: dict) -> RawMessage:
        """ì¹´ì¹´ì˜¤í†¡ ì›¹í›…ìœ¼ë¡œ ìˆ˜ì‹ ëœ ë©”ì‹œì§€ ì²˜ë¦¬"""
        
        # ë©”ì‹œì§€ ìœ í˜• ë¶„ë¥˜
        msg_type = payload.get('type')
        
        if msg_type == 'text':
            content = payload['content']['text']
        elif msg_type == 'photo':
            # ì´ë¯¸ì§€ì¸ ê²½ìš° OCR ì²˜ë¦¬ ëŒ€ê¸°ì—´ì— ì¶”ê°€
            content = await self._process_image(payload['content']['url'])
        elif msg_type == 'voice':
            # ìŒì„±ì¸ ê²½ìš° STT ì²˜ë¦¬
            content = await self._process_voice(payload['content']['url'])
        else:
            content = str(payload.get('content', ''))
        
        # ì´ì „ ëŒ€í™” ë§¥ë½ ì¡°íšŒ (ìµœê·¼ 5ê°œ ë©”ì‹œì§€)
        context = await self._get_conversation_context(
            user_id=payload['sender']['id'],
            limit=5
        )
        
        return RawMessage(
            message_id=payload['id'],
            channel='kakao',
            sender_id=payload['sender']['id'],
            sender_name=payload['sender'].get('nickname', ''),
            content=content,
            attachments=payload.get('attachments', []),
            timestamp=datetime.fromisoformat(payload['timestamp']),
            context_messages=context
        )
    
    async def _process_image(self, image_url: str) -> str:
        """ì´ë¯¸ì§€ì—ì„œ í…ìŠ¤íŠ¸ ì¶”ì¶œ (ì£¼ë¬¸ì„œ ìº¡ì²˜ ë“±)"""
        # Naver Clova OCR ë˜ëŠ” Google Vision API ì‚¬ìš©
        pass
    
    async def _process_voice(self, voice_url: str) -> str:
        """ìŒì„± ë©”ì‹œì§€ë¥¼ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜"""
        # Whisper API ë˜ëŠ” Google Speech-to-Text ì‚¬ìš©
        pass
1.2 ë©€í‹° ì±„ë„ í†µí•© ìˆ˜ì§‘ê¸°
python# multi_channel_aggregator.py
from abc import ABC, abstractmethod
from kafka import KafkaProducer, KafkaConsumer
import json

class ChannelConnector(ABC):
    """ì±„ë„ë³„ ì»¤ë„¥í„° ì¶”ìƒ í´ë˜ìŠ¤"""
    
    @abstractmethod
    async def connect(self):
        pass
    
    @abstractmethod
    async def collect_messages(self) -> List[RawMessage]:
        pass

class BandConnector(ChannelConnector):
    """ë„¤ì´ë²„ ë°´ë“œ ë©”ì‹œì§€ ìˆ˜ì§‘"""
    
    async def collect_messages(self) -> List[RawMessage]:
        # ë°´ë“œ API ë˜ëŠ” ì›¹ í¬ë¡¤ë§
        pass

class InstagramConnector(ChannelConnector):
    """ì¸ìŠ¤íƒ€ê·¸ë¨ DM/ëŒ“ê¸€ ìˆ˜ì§‘"""
    
    async def collect_messages(self) -> List[RawMessage]:
        # Instagram Graph API ì‚¬ìš©
        pass

class MessageAggregator:
    """
    ëª¨ë“  ì±„ë„ì˜ ë©”ì‹œì§€ë¥¼ í†µí•© ìˆ˜ì§‘í•˜ì—¬ Kafkaë¡œ ì „ì†¡
    """
    
    def __init__(self, kafka_bootstrap: str):
        self.producer = KafkaProducer(
            bootstrap_servers=kafka_bootstrap,
            value_serializer=lambda v: json.dumps(v, default=str).encode('utf-8')
        )
        self.connectors: List[ChannelConnector] = []
    
    def register_connector(self, connector: ChannelConnector):
        self.connectors.append(connector)
    
    async def run(self):
        """ëª¨ë“  ì±„ë„ì—ì„œ ë©”ì‹œì§€ ìˆ˜ì§‘ ë° í ì „ì†¡"""
        while True:
            for connector in self.connectors:
                messages = await connector.collect_messages()
                for msg in messages:
                    self.producer.send(
                        'raw-orders',
                        value=msg.__dict__
                    )
            await asyncio.sleep(1)  # 1ì´ˆ ê°„ê²© í´ë§

2ë‹¨ê³„: ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
2.1 í…ìŠ¤íŠ¸ ì •ê·œí™”
python# preprocessor.py
import re
from typing import Dict, List, Tuple
from konlpy.tag import Okt
from pykospacing import Spacing

class TextPreprocessor:
    """
    í•œêµ­ì–´ ë¹„ì •í˜• í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬
    - ì˜¤íƒ€ êµì •
    - ë„ì–´ì“°ê¸° êµì •
    - ì´ëª¨ì§€/íŠ¹ìˆ˜ë¬¸ì ì²˜ë¦¬
    - ìˆ«ì í‘œí˜„ ì •ê·œí™”
    """
    
    def __init__(self):
        self.okt = Okt()
        self.spacing = Spacing()
        
        # ìì£¼ ë°œìƒí•˜ëŠ” ì˜¤íƒ€ ì‚¬ì „
        self.typo_dict = {
            'ë°°ì¸„': 'ë°°ì¶”', 'ë¬´ìš°': 'ë¬´', 'ê³ ì¶”ì¥ì°Œê²Œ': 'ê³ ì¶”ì¥ì°Œê°œ',
            'ì¬ìœ¡': 'ì œìœ¡', 'ì‚¼ê²¹ì‚´': 'ì‚¼ê²¹ì‚´', 'ê°ì¹˜': 'ê¹€ì¹˜',
            'ê¹ë‘ê¸°': 'ê¹ë‘ê¸°', 'ê°ˆì¹˜': 'ê°ˆì¹˜', 'ê³ ë“±ì–´': 'ê³ ë“±ì–´',
            'ì‚¬ê³¼': 'ì‚¬ê³¼', 'ë°°': 'ë°°', 'ê·¤': 'ê·¤',
        }
        
        # ìˆ˜ëŸ‰ í‘œí˜„ ì •ê·œí™”
        self.quantity_patterns = [
            (r'(\d+)\s*ê°œ', r'\1ê°œ'),
            (r'(\d+)\s*ë°•ìŠ¤', r'\1ë°•ìŠ¤'),
            (r'(\d+)\s*kg', r'\1kg'),
            (r'(\d+)\s*ì¸ë¶„', r'\1ì¸ë¶„'),
            (r'í•œ\s*ê°œ', '1ê°œ'),
            (r'ë‘\s*ê°œ', '2ê°œ'),
            (r'ì„¸\s*ê°œ', '3ê°œ'),
            (r'í•œ\s*ë°•ìŠ¤', '1ë°•ìŠ¤'),
        ]
    
    def preprocess(self, text: str) -> Dict:
        """ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ì‹¤í–‰"""
        
        original = text
        
        # 1. ì´ëª¨ì§€ ì œê±° (ì˜ë¯¸ ë³´ì¡´ì´ í•„ìš”í•œ ê²½ìš° íƒœê¹…)
        text, emojis = self._extract_emojis(text)
        
        # 2. ë„ì–´ì“°ê¸° êµì •
        text = self.spacing(text)
        
        # 3. ì˜¤íƒ€ êµì •
        text = self._correct_typos(text)
        
        # 4. ìˆ˜ëŸ‰ í‘œí˜„ ì •ê·œí™”
        text = self._normalize_quantities(text)
        
        # 5. íŠ¹ìˆ˜ë¬¸ì ì •ë¦¬
        text = self._clean_special_chars(text)
        
        return {
            'original': original,
            'processed': text,
            'emojis': emojis,
            'corrections': self._get_corrections(original, text)
        }
    
    def _extract_emojis(self, text: str) -> Tuple[str, List[str]]:
        """ì´ëª¨ì§€ ì¶”ì¶œ ë° ì œê±°"""
        emoji_pattern = re.compile(
            "["
            "\U0001F600-\U0001F64F"  # ì´ëª¨í‹°ì½˜
            "\U0001F300-\U0001F5FF"  # ê¸°í˜¸ ë° í”½í† ê·¸ë¨
            "\U0001F680-\U0001F6FF"  # êµí†µ ë° ì§€ë„ ê¸°í˜¸
            "\U0001F1E0-\U0001F1FF"  # êµ­ê¸°
            "]+",
            flags=re.UNICODE
        )
        emojis = emoji_pattern.findall(text)
        clean_text = emoji_pattern.sub('', text)
        return clean_text, emojis
    
    def _correct_typos(self, text: str) -> str:
        """ì˜¤íƒ€ êµì •"""
        for typo, correct in self.typo_dict.items():
            text = text.replace(typo, correct)
        return text
    
    def _normalize_quantities(self, text: str) -> str:
        """ìˆ˜ëŸ‰ í‘œí˜„ ì •ê·œí™”"""
        for pattern, replacement in self.quantity_patterns:
            text = re.sub(pattern, replacement, text)
        return text
    
    def _clean_special_chars(self, text: str) -> str:
        """íŠ¹ìˆ˜ë¬¸ì ì •ë¦¬ (í•„ìš”í•œ ê²ƒë§Œ ìœ ì§€)"""
        # ìˆ«ì, í•œê¸€, ì˜ë¬¸, í•„ìˆ˜ íŠ¹ìˆ˜ë¬¸ìë§Œ ìœ ì§€
        text = re.sub(r'[^\w\sê°€-í£0-9@.,!?~\-]', ' ', text)
        text = re.sub(r'\s+', ' ', text).strip()
        return text

3ë‹¨ê³„: LLM ê¸°ë°˜ ì •í˜•í™” ì—”ì§„ (í•µì‹¬)
3.1 Multi-Agent ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
python# llm_extraction_engine.py
from openai import OpenAI
from anthropic import Anthropic
from pydantic import BaseModel, Field
from typing import List, Optional, Literal
from enum import Enum
import json

# ì •í˜•í™”ëœ ì£¼ë¬¸ ë°ì´í„° ìŠ¤í‚¤ë§ˆ
class OrderItem(BaseModel):
    """ê°œë³„ ì£¼ë¬¸ ìƒí’ˆ"""
    product_name: str = Field(description="ìƒí’ˆëª…")
    product_id: Optional[str] = Field(description="ìƒí’ˆ ì½”ë“œ (ë§¤ì¹­ëœ ê²½ìš°)")
    quantity: int = Field(description="ìˆ˜ëŸ‰", ge=1)
    unit: str = Field(description="ë‹¨ìœ„ (ê°œ, ë°•ìŠ¤, kg, ì¸ë¶„ ë“±)")
    unit_price: Optional[int] = Field(description="ë‹¨ê°€")
    options: List[str] = Field(default=[], description="ì˜µì…˜ (ë§µê¸°, í¬ê¸° ë“±)")
    special_request: Optional[str] = Field(description="íŠ¹ë³„ ìš”ì²­ì‚¬í•­")
    confidence: float = Field(description="ì¶”ì¶œ ì‹ ë¢°ë„", ge=0, le=1)

class DeliveryInfo(BaseModel):
    """ë°°ì†¡ ì •ë³´"""
    recipient_name: Optional[str] = Field(description="ìˆ˜ë ¹ì¸")
    phone: Optional[str] = Field(description="ì—°ë½ì²˜")
    address: Optional[str] = Field(description="ë°°ì†¡ ì£¼ì†Œ")
    delivery_date: Optional[str] = Field(description="ë°°ì†¡ í¬ë§ì¼")
    delivery_time: Optional[str] = Field(description="ë°°ì†¡ í¬ë§ ì‹œê°„")
    delivery_memo: Optional[str] = Field(description="ë°°ì†¡ ë©”ëª¨")

class PaymentInfo(BaseModel):
    """ê²°ì œ ì •ë³´"""
    method: Optional[Literal['card', 'cash', 'transfer', 'later']] = Field(description="ê²°ì œ ë°©ì‹")
    status: Literal['pending', 'completed', 'unknown'] = Field(description="ê²°ì œ ìƒíƒœ")

class StructuredOrder(BaseModel):
    """ì •í˜•í™”ëœ ì£¼ë¬¸ ë°ì´í„°"""
    order_id: str
    customer_id: str
    customer_name: str
    channel: str
    items: List[OrderItem]
    delivery: DeliveryInfo
    payment: PaymentInfo
    total_amount: Optional[int]
    raw_message: str
    overall_confidence: float
    requires_confirmation: bool
    confirmation_items: List[str] = Field(default=[], description="í™•ì¸ì´ í•„ìš”í•œ í•­ëª©ë“¤")

class OrderExtractionEngine:
    """
    LLM ê¸°ë°˜ ì£¼ë¬¸ ì •í˜•í™” ì—”ì§„
    - Claude/GPTë¥¼ í™œìš©í•œ ì—”í‹°í‹° ì¶”ì¶œ
    - RAGë¥¼ í†µí•œ ìƒí’ˆ ë§¤ì¹­
    - Multi-Agent í˜‘ì—… ì²˜ë¦¬
    """
    
    def __init__(self, anthropic_key: str, product_catalog: 'ProductCatalog'):
        self.client = Anthropic(api_key=anthropic_key)
        self.product_catalog = product_catalog
        
        # ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
        self.system_prompt = """ë‹¹ì‹ ì€ ì‹í’ˆ ì£¼ë¬¸ ë©”ì‹œì§€ë¥¼ ë¶„ì„í•˜ëŠ” ì „ë¬¸ AIì…ë‹ˆë‹¤.
        
## ì—­í• 
ê³ ê°ì´ ë³´ë‚¸ ë¹„ì •í˜• ì£¼ë¬¸ ë©”ì‹œì§€ì—ì„œ ì •í˜•í™”ëœ ì£¼ë¬¸ ì •ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.

## ì¶”ì¶œí•´ì•¼ í•  ì •ë³´
1. ìƒí’ˆ ì •ë³´: ìƒí’ˆëª…, ìˆ˜ëŸ‰, ë‹¨ìœ„, ì˜µì…˜
2. ë°°ì†¡ ì •ë³´: ìˆ˜ë ¹ì¸, ì—°ë½ì²˜, ì£¼ì†Œ, ë°°ì†¡ í¬ë§ì¼/ì‹œê°„
3. ê²°ì œ ì •ë³´: ê²°ì œ ë°©ì‹, ê²°ì œ ìƒíƒœ
4. íŠ¹ë³„ ìš”ì²­ì‚¬í•­

## ì£¼ì˜ì‚¬í•­
- ëª¨í˜¸í•œ í‘œí˜„ì€ confidenceë¥¼ ë‚®ê²Œ ì„¤ì •í•˜ê³  requires_confirmationì„ trueë¡œ ì„¤ì •
- "ì €ë²ˆì²˜ëŸ¼", "í‰ì†ŒëŒ€ë¡œ" ë“± ë§¥ë½ ì˜ì¡´ì  í‘œí˜„ì€ context_messages ì°¸ì¡°
- ìƒí’ˆëª…ì´ ë¶ˆëª…í™•í•˜ë©´ ìœ ì‚¬ ìƒí’ˆ ëª©ë¡ì—ì„œ ë§¤ì¹­ ì‹œë„
- ìˆ˜ëŸ‰ì´ ëª…ì‹œë˜ì§€ ì•Šìœ¼ë©´ ê¸°ë³¸ê°’ 1ë¡œ ì„¤ì •í•˜ë˜ confidence ë‚®ì¶¤
- ë°©ì–¸, ì¤„ì„ë§, ì˜¤íƒ€ê°€ ìˆì–´ë„ ìµœëŒ€í•œ ì˜ë„ íŒŒì•…

## ì¶œë ¥ í˜•ì‹
ë°˜ë“œì‹œ ì§€ì •ëœ JSON ìŠ¤í‚¤ë§ˆë¥¼ ë”°ë¼ ì¶œë ¥í•˜ì„¸ìš”."""

    async def extract_order(
        self, 
        message: RawMessage,
        customer_history: Optional[List[dict]] = None
    ) -> StructuredOrder:
        """
        ë¹„ì •í˜• ë©”ì‹œì§€ì—ì„œ ì •í˜• ì£¼ë¬¸ ë°ì´í„° ì¶”ì¶œ
        """
        
        # 1. ìƒí’ˆ ì¹´íƒˆë¡œê·¸ì—ì„œ ê´€ë ¨ ìƒí’ˆ ê²€ìƒ‰ (RAG)
        relevant_products = await self.product_catalog.search(
            query=message.content,
            top_k=10
        )
        
        # 2. ê³ ê° ì£¼ë¬¸ íˆìŠ¤í† ë¦¬ ì¡°íšŒ
        if customer_history is None:
            customer_history = await self._get_customer_history(message.sender_id)
        
        # 3. LLM í”„ë¡¬í”„íŠ¸ êµ¬ì„±
        user_prompt = self._build_extraction_prompt(
            message=message,
            products=relevant_products,
            history=customer_history
        )
        
        # 4. Claude API í˜¸ì¶œ (Structured Output)
        response = self.client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2000,
            system=self.system_prompt,
            messages=[{"role": "user", "content": user_prompt}],
            # Tool use for structured output
            tools=[{
                "name": "submit_order",
                "description": "ì¶”ì¶œëœ ì£¼ë¬¸ ì •ë³´ë¥¼ ì œì¶œí•©ë‹ˆë‹¤",
                "input_schema": StructuredOrder.model_json_schema()
            }],
            tool_choice={"type": "tool", "name": "submit_order"}
        )
        
        # 5. ì‘ë‹µ íŒŒì‹±
        tool_use = next(
            block for block in response.content 
            if block.type == "tool_use"
        )
        
        order_data = tool_use.input
        
        # 6. ìƒí’ˆ ID ë§¤ì¹­ ë° ê°€ê²© ê³„ì‚°
        order = await self._enrich_order(order_data, relevant_products)
        
        return order
    
    def _build_extraction_prompt(
        self, 
        message: RawMessage,
        products: List[dict],
        history: List[dict]
    ) -> str:
        """ì¶”ì¶œìš© í”„ë¡¬í”„íŠ¸ êµ¬ì„±"""
        
        prompt = f"""## ì£¼ë¬¸ ë©”ì‹œì§€
ì±„ë„: {message.channel}
ë°œì‹ ì: {message.sender_name} ({message.sender_id})
ì‹œê°„: {message.timestamp}

### ë©”ì‹œì§€ ë‚´ìš©
{message.content}

### ì´ì „ ëŒ€í™” ë§¥ë½
{json.dumps(message.context_messages, ensure_ascii=False, indent=2)}

## íŒë§¤ ìƒí’ˆ ëª©ë¡ (ì°¸ê³ ìš©)
{json.dumps(products, ensure_ascii=False, indent=2)}

## ê³ ê° ì£¼ë¬¸ ì´ë ¥ (ìµœê·¼ 5ê±´)
{json.dumps(history[-5:] if history else [], ensure_ascii=False, indent=2)}

ìœ„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì£¼ë¬¸ ì •ë³´ë¥¼ ì¶”ì¶œí•´ì£¼ì„¸ìš”.
ëª¨í˜¸í•˜ê±°ë‚˜ í™•ì¸ì´ í•„ìš”í•œ í•­ëª©ì€ ë°˜ë“œì‹œ í‘œì‹œí•´ì£¼ì„¸ìš”."""

        return prompt
    
    async def _enrich_order(
        self, 
        order_data: dict,
        products: List[dict]
    ) -> StructuredOrder:
        """ìƒí’ˆ ë§¤ì¹­ ë° ê°€ê²© ê³„ì‚°ìœ¼ë¡œ ì£¼ë¬¸ ë°ì´í„° ë³´ê°•"""
        
        total_amount = 0
        enriched_items = []
        
        for item in order_data.get('items', []):
            # ìƒí’ˆ ì¹´íƒˆë¡œê·¸ì—ì„œ ì •í™•í•œ ë§¤ì¹­
            matched_product = self.product_catalog.find_best_match(
                item['product_name'],
                products
            )
            
            if matched_product:
                item['product_id'] = matched_product['id']
                item['unit_price'] = matched_product['price']
                total_amount += matched_product['price'] * item['quantity']
            
            enriched_items.append(OrderItem(**item))
        
        order_data['items'] = enriched_items
        order_data['total_amount'] = total_amount
        
        return StructuredOrder(**order_data)
3.2 ìƒí’ˆ ì¹´íƒˆë¡œê·¸ RAG ì‹œìŠ¤í…œ
python# product_catalog.py
from sentence_transformers import SentenceTransformer
import chromadb
from chromadb.config import Settings
import numpy as np
from typing import List, Dict, Optional

class ProductCatalog:
    """
    ìƒí’ˆ ì¹´íƒˆë¡œê·¸ ë²¡í„° ê²€ìƒ‰ ì‹œìŠ¤í…œ
    - í•œêµ­ì–´ ì„ë² ë”© ëª¨ë¸ ì‚¬ìš©
    - ìœ ì‚¬ ìƒí’ˆ ê²€ìƒ‰ìœ¼ë¡œ ì˜¤íƒ€/ë³€í˜• ì²˜ë¦¬
    """
    
    def __init__(self, collection_name: str = "products"):
        # í•œêµ­ì–´ íŠ¹í™” ì„ë² ë”© ëª¨ë¸
        self.encoder = SentenceTransformer('jhgan/ko-sroberta-multitask')
        
        # ChromaDB ë²¡í„° ìŠ¤í† ì–´
        self.chroma_client = chromadb.Client(Settings(
            chroma_db_impl="duckdb+parquet",
            persist_directory="./chroma_db"
        ))
        
        self.collection = self.chroma_client.get_or_create_collection(
            name=collection_name,
            metadata={"hnsw:space": "cosine"}
        )
    
    def add_products(self, products: List[Dict]):
        """ìƒí’ˆ ì¹´íƒˆë¡œê·¸ ë“±ë¡"""
        
        for product in products:
            # ê²€ìƒ‰ìš© í…ìŠ¤íŠ¸ êµ¬ì„± (ìƒí’ˆëª… + ì¹´í…Œê³ ë¦¬ + í‚¤ì›Œë“œ)
            search_text = f"{product['name']} {product.get('category', '')} {' '.join(product.get('keywords', []))}"
            
            # ì„ë² ë”© ìƒì„±
            embedding = self.encoder.encode(search_text).tolist()
            
            self.collection.add(
                ids=[product['id']],
                embeddings=[embedding],
                metadatas=[product],
                documents=[search_text]
            )
    
    async def search(
        self, 
        query: str, 
        top_k: int = 10,
        threshold: float = 0.5
    ) -> List[Dict]:
        """ìœ ì‚¬ ìƒí’ˆ ê²€ìƒ‰"""
        
        # ì¿¼ë¦¬ ì„ë² ë”©
        query_embedding = self.encoder.encode(query).tolist()
        
        # ë²¡í„° ê²€ìƒ‰
        results = self.collection.query(
            query_embeddings=[query_embedding],
            n_results=top_k
        )
        
        products = []
        for i, (id, metadata, distance) in enumerate(zip(
            results['ids'][0],
            results['metadatas'][0],
            results['distances'][0]
        )):
            similarity = 1 - distance  # cosine distance to similarity
            if similarity >= threshold:
                metadata['similarity'] = similarity
                products.append(metadata)
        
        return products
    
    def find_best_match(
        self, 
        product_name: str,
        candidates: List[Dict]
    ) -> Optional[Dict]:
        """í›„ë³´ ì¤‘ ê°€ì¥ ìœ ì‚¬í•œ ìƒí’ˆ ë§¤ì¹­"""
        
        if not candidates:
            return None
        
        # ì´ë¦„ ê¸°ë°˜ ì •í™• ë§¤ì¹­ ìš°ì„ 
        for candidate in candidates:
            if candidate['name'] == product_name:
                return candidate
        
        # ìœ ì‚¬ë„ ê¸°ë°˜ ë§¤ì¹­
        query_embedding = self.encoder.encode(product_name)
        
        best_match = None
        best_similarity = 0
        
        for candidate in candidates:
            candidate_embedding = self.encoder.encode(candidate['name'])
            similarity = np.dot(query_embedding, candidate_embedding) / (
                np.linalg.norm(query_embedding) * np.linalg.norm(candidate_embedding)
            )
            
            if similarity > best_similarity and similarity > 0.7:
                best_similarity = similarity
                best_match = candidate
        
        return best_match
3.3 ì»¨í…ìŠ¤íŠ¸ í•´ì„ê¸° (ë‹¨ê³¨ ê³ ê° ë§¥ë½ ì²˜ë¦¬)
python# context_interpreter.py
from typing import Dict, List, Optional
import redis
import json

class CustomerContextManager:
    """
    ê³ ê°ë³„ ì»¨í…ìŠ¤íŠ¸ ê´€ë¦¬
    - ì£¼ë¬¸ íˆìŠ¤í† ë¦¬ ê¸°ë°˜ "ì €ë²ˆì²˜ëŸ¼" í•´ì„
    - ë‹¨ê³¨ ê³ ê° ì„ í˜¸ë„ í•™ìŠµ
    - ì£¼ì†Œ, ê²°ì œë°©ì‹ ë“± ê¸°ë³¸ ì •ë³´ ìºì‹±
    """
    
    def __init__(self, redis_host: str = 'localhost'):
        self.redis = redis.Redis(host=redis_host, decode_responses=True)
    
    async def get_customer_context(self, customer_id: str) -> Dict:
        """ê³ ê° ì»¨í…ìŠ¤íŠ¸ ì¡°íšŒ"""
        
        context = {
            'profile': await self._get_profile(customer_id),
            'recent_orders': await self._get_recent_orders(customer_id),
            'preferences': await self._get_preferences(customer_id),
            'frequently_ordered': await self._get_frequent_items(customer_id)
        }
        
        return context
    
    async def _get_profile(self, customer_id: str) -> Dict:
        """ê³ ê° ê¸°ë³¸ ì •ë³´"""
        profile_key = f"customer:{customer_id}:profile"
        profile = self.redis.hgetall(profile_key)
        return profile or {}
    
    async def _get_recent_orders(self, customer_id: str, limit: int = 10) -> List[Dict]:
        """ìµœê·¼ ì£¼ë¬¸ ë‚´ì—­"""
        orders_key = f"customer:{customer_id}:orders"
        orders = self.redis.lrange(orders_key, 0, limit - 1)
        return [json.loads(o) for o in orders]
    
    async def _get_preferences(self, customer_id: str) -> Dict:
        """ê³ ê° ì„ í˜¸ë„ (ë§µê¸°, ë‹¨ë§› ë“±)"""
        pref_key = f"customer:{customer_id}:preferences"
        return self.redis.hgetall(pref_key) or {}
    
    async def _get_frequent_items(self, customer_id: str, top_k: int = 5) -> List[Dict]:
        """ìì£¼ ì£¼ë¬¸í•˜ëŠ” ìƒí’ˆ"""
        freq_key = f"customer:{customer_id}:frequent_items"
        items = self.redis.zrevrange(freq_key, 0, top_k - 1, withscores=True)
        return [{'product_id': item[0], 'count': int(item[1])} for item in items]
    
    async def resolve_reference(
        self, 
        reference: str, 
        customer_id: str
    ) -> Optional[Dict]:
        """
        ë§¥ë½ ì˜ì¡´ì  í‘œí˜„ í•´ì„
        ì˜ˆ: "ì €ë²ˆì²˜ëŸ¼", "í‰ì†ŒëŒ€ë¡œ", "ê·¸ê±°", "ëŠ˜ ë¨¹ë˜ ê±°"
        """
        
        context = await self.get_customer_context(customer_id)
        
        reference_lower = reference.lower()
        
        # "ì €ë²ˆì²˜ëŸ¼", "ì§€ë‚œë²ˆì²˜ëŸ¼" -> ê°€ì¥ ìµœê·¼ ì£¼ë¬¸
        if any(kw in reference_lower for kw in ['ì €ë²ˆ', 'ì§€ë‚œë²ˆ', 'ì „ì—']):
            if context['recent_orders']:
                return {
                    'type': 'last_order',
                    'resolved': context['recent_orders'][0]
                }
        
        # "í‰ì†ŒëŒ€ë¡œ", "ëŠ˜ ë¨¹ë˜" -> ìì£¼ ì£¼ë¬¸í•˜ëŠ” ìƒí’ˆ
        if any(kw in reference_lower for kw in ['í‰ì†Œ', 'ëŠ˜', 'í•­ìƒ', 'ë§¨ë‚ ']):
            if context['frequently_ordered']:
                return {
                    'type': 'frequent_order',
                    'resolved': context['frequently_ordered']
                }
        
        # "ê°™ì€ ì£¼ì†Œë¡œ" -> ì €ì¥ëœ ì£¼ì†Œ
        if any(kw in reference_lower for kw in ['ê°™ì€ ì£¼ì†Œ', 'ì €ë²ˆ ì£¼ì†Œ', 'ê·¸ ì£¼ì†Œ']):
            if context['profile'].get('default_address'):
                return {
                    'type': 'saved_address',
                    'resolved': context['profile']['default_address']
                }
        
        return None
    
    async def update_customer_context(
        self, 
        customer_id: str, 
        order: 'StructuredOrder'
    ):
        """ì£¼ë¬¸ ì™„ë£Œ í›„ ê³ ê° ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸"""
        
        # ì£¼ë¬¸ íˆìŠ¤í† ë¦¬ ì¶”ê°€
        orders_key = f"customer:{customer_id}:orders"
        self.redis.lpush(orders_key, json.dumps(order.dict()))
        self.redis.ltrim(orders_key, 0, 99)  # ìµœê·¼ 100ê°œë§Œ ìœ ì§€
        
        # ìì£¼ ì£¼ë¬¸ ìƒí’ˆ ì—…ë°ì´íŠ¸
        freq_key = f"customer:{customer_id}:frequent_items"
        for item in order.items:
            self.redis.zincrby(freq_key, item.quantity, item.product_id)
        
        # ê¸°ë³¸ ë°°ì†¡ì§€ ì—…ë°ì´íŠ¸
        if order.delivery.address:
            profile_key = f"customer:{customer_id}:profile"
            self.redis.hset(profile_key, 'default_address', order.delivery.address)

4ë‹¨ê³„: ê²€ì¦ ë° í™•ì¸ ì‹œìŠ¤í…œ
4.1 ì‹ ë¢°ë„ í‰ê°€ ë° í”Œë˜ê·¸ ì²˜ë¦¬
python# validation_engine.py
from dataclasses import dataclass
from typing import List, Tuple
from enum import Enum

class ConfidenceLevel(Enum):
    HIGH = "high"       # 95% ì´ìƒ - ìë™ ì²˜ë¦¬
    MEDIUM = "medium"   # 70-95% - ë¹ ë¥¸ í™•ì¸ í•„ìš”
    LOW = "low"         # 50-70% - ìƒì„¸ í™•ì¸ í•„ìš”
    VERY_LOW = "very_low"  # 50% ë¯¸ë§Œ - ìˆ˜ë™ ì²˜ë¦¬

@dataclass
class ValidationResult:
    """ê²€ì¦ ê²°ê³¼"""
    is_valid: bool
    confidence_level: ConfidenceLevel
    issues: List[str]
    suggestions: List[str]
    requires_human_review: bool

class OrderValidator:
    """
    ì£¼ë¬¸ ë°ì´í„° ê²€ì¦ê¸°
    - í•„ìˆ˜ í•„ë“œ ê²€ì¦
    - ë…¼ë¦¬ì  ì¼ê´€ì„± ê²€ì‚¬
    - ì‹ ë¢°ë„ ê¸°ë°˜ ìë™/ìˆ˜ë™ ì²˜ë¦¬ ë¶„ê¸°
    """
    
    def __init__(self, auto_approve_threshold: float = 0.85):
        self.auto_approve_threshold = auto_approve_threshold
    
    def validate(self, order: StructuredOrder) -> ValidationResult:
        """ì£¼ë¬¸ ë°ì´í„° ê²€ì¦"""
        
        issues = []
        suggestions = []
        
        # 1. í•„ìˆ˜ í•„ë“œ ê²€ì¦
        if not order.items:
            issues.append("ì£¼ë¬¸ ìƒí’ˆì´ ì—†ìŠµë‹ˆë‹¤")
        
        for i, item in enumerate(order.items):
            if not item.product_name:
                issues.append(f"ìƒí’ˆ {i+1}: ìƒí’ˆëª…ì´ ì—†ìŠµë‹ˆë‹¤")
            if item.quantity <= 0:
                issues.append(f"ìƒí’ˆ {i+1}: ìˆ˜ëŸ‰ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤")
            if item.confidence < 0.5:
                issues.append(f"ìƒí’ˆ {i+1}: '{item.product_name}' ì¸ì‹ ì‹ ë¢°ë„ê°€ ë‚®ìŠµë‹ˆë‹¤ ({item.confidence:.0%})")
        
        # 2. ë°°ì†¡ ì •ë³´ ê²€ì¦
        if not order.delivery.address and not order.delivery.recipient_name:
            issues.append("ë°°ì†¡ ì •ë³´ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤")
            suggestions.append("ê³ ê°ì—ê²Œ ë°°ì†¡ ì£¼ì†Œ í™•ì¸ í•„ìš”")
        
        # 3. ë…¼ë¦¬ì  ì¼ê´€ì„± ê²€ì‚¬
        if order.total_amount and order.total_amount > 1000000:
            issues.append(f"ì£¼ë¬¸ ê¸ˆì•¡ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ë†’ìŠµë‹ˆë‹¤: {order.total_amount:,}ì›")
            suggestions.append("ìˆ˜ëŸ‰ ë˜ëŠ” ìƒí’ˆ í™•ì¸ í•„ìš”")
        
        # 4. ì‹ ë¢°ë„ ë ˆë²¨ ê²°ì •
        confidence_level = self._determine_confidence_level(order.overall_confidence)
        
        # 5. ìë™ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì •
        requires_human = (
            confidence_level in [ConfidenceLevel.LOW, ConfidenceLevel.VERY_LOW] or
            len(issues) > 0 or
            order.requires_confirmation
        )
        
        return ValidationResult(
            is_valid=len(issues) == 0,
            confidence_level=confidence_level,
            issues=issues,
            suggestions=suggestions + order.confirmation_items,
            requires_human_review=requires_human
        )
    
    def _determine_confidence_level(self, confidence: float) -> ConfidenceLevel:
        if confidence >= 0.95:
            return ConfidenceLevel.HIGH
        elif confidence >= 0.70:
            return ConfidenceLevel.MEDIUM
        elif confidence >= 0.50:
            return ConfidenceLevel.LOW
        else:
            return ConfidenceLevel.VERY_LOW
4.2 íŒë§¤ì í™•ì¸ ëŒ€ì‹œë³´ë“œ API
python# seller_dashboard.py
from fastapi import FastAPI, WebSocket, HTTPException
from fastapi.responses import HTMLResponse
from typing import List
import asyncio

app = FastAPI()

class PendingOrderManager:
    """í™•ì¸ ëŒ€ê¸° ì£¼ë¬¸ ê´€ë¦¬"""
    
    def __init__(self):
        self.pending_orders: Dict[str, StructuredOrder] = {}
        self.websocket_connections: List[WebSocket] = []
    
    async def add_pending_order(self, order: StructuredOrder, validation: ValidationResult):
        """í™•ì¸ í•„ìš” ì£¼ë¬¸ ì¶”ê°€"""
        self.pending_orders[order.order_id] = {
            'order': order,
            'validation': validation,
            'status': 'pending'
        }
        
        # ì‹¤ì‹œê°„ ì•Œë¦¼ ì „ì†¡
        await self._notify_sellers(order, validation)
    
    async def _notify_sellers(self, order: StructuredOrder, validation: ValidationResult):
        """WebSocketìœ¼ë¡œ íŒë§¤ìì—ê²Œ ì‹¤ì‹œê°„ ì•Œë¦¼"""
        notification = {
            'type': 'new_order',
            'order_id': order.order_id,
            'customer_name': order.customer_name,
            'items_summary': [f"{item.product_name} x {item.quantity}" for item in order.items],
            'issues': validation.issues,
            'confidence': order.overall_confidence
        }
        
        for ws in self.websocket_connections:
            await ws.send_json(notification)

pending_manager = PendingOrderManager()

@app.websocket("/ws/orders")
async def websocket_endpoint(websocket: WebSocket):
    """íŒë§¤ì ì‹¤ì‹œê°„ ì•Œë¦¼ ì›¹ì†Œì¼“"""
    await websocket.accept()
    pending_manager.websocket_connections.append(websocket)
    
    try:
        while True:
            data = await websocket.receive_json()
            
            if data['action'] == 'approve':
                await approve_order(data['order_id'])
            elif data['action'] == 'reject':
                await reject_order(data['order_id'], data.get('reason'))
            elif data['action'] == 'modify':
                await modify_order(data['order_id'], data['modifications'])
    
    except Exception as e:
        pending_manager.websocket_connections.remove(websocket)

@app.get("/api/pending-orders")
async def get_pending_orders():
    """í™•ì¸ ëŒ€ê¸° ì£¼ë¬¸ ëª©ë¡ ì¡°íšŒ"""
    return list(pending_manager.pending_orders.values())

@app.post("/api/orders/{order_id}/approve")
async def approve_order(order_id: str):
    """ì£¼ë¬¸ ìŠ¹ì¸"""
    if order_id not in pending_manager.pending_orders:
        raise HTTPException(status_code=404, detail="Order not found")
    
    order_data = pending_manager.pending_orders.pop(order_id)
    order = order_data['order']
    
    # ì—‘ì…€ ìë™í™” ë° í›„ì† ì²˜ë¦¬
    await process_approved_order(order)
    
    return {"status": "approved", "order_id": order_id}

@app.post("/api/orders/{order_id}/modify")
async def modify_order(order_id: str, modifications: dict):
    """ì£¼ë¬¸ ìˆ˜ì • í›„ ìŠ¹ì¸"""
    if order_id not in pending_manager.pending_orders:
        raise HTTPException(status_code=404, detail="Order not found")
    
    order_data = pending_manager.pending_orders[order_id]
    order = order_data['order']
    
    # ìˆ˜ì • ì‚¬í•­ ì ìš©
    for key, value in modifications.items():
        if hasattr(order, key):
            setattr(order, key, value)
    
    # ìŠ¹ì¸ ì²˜ë¦¬
    pending_manager.pending_orders.pop(order_id)
    await process_approved_order(order)
    
    return {"status": "modified_and_approved", "order_id": order_id}

5ë‹¨ê³„: ì—‘ì…€ ìë™í™” ì¶œë ¥
5.1 ì—‘ì…€/êµ¬ê¸€ì‹œíŠ¸ ìë™ ìƒì„±
python# excel_automation.py
import openpyxl
from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
from openpyxl.utils import get_column_letter
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from datetime import datetime, date
from typing import List
import pandas as pd

class ExcelOrderExporter:
    """
    ì£¼ë¬¸ ë°ì´í„° ì—‘ì…€ ìë™ ìƒì„±
    - ì¼ë³„/ì£¼ë³„ ì£¼ë¬¸ì„œ ìë™ ìƒì„±
    - ë°°ì†¡ ë¼ë²¨ìš© ë°ì´í„° ì¶”ì¶œ
    - ì •ì‚°ìš© ë°ì´í„° ìƒì„±
    """
    
    def __init__(self, template_path: str = None):
        self.template_path = template_path
        
        # ìŠ¤íƒ€ì¼ ì •ì˜
        self.header_font = Font(bold=True, size=11)
        self.header_fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
        self.border = Border(
            left=Side(style='thin'),
            right=Side(style='thin'),
            top=Side(style='thin'),
            bottom=Side(style='thin')
        )
    
    def export_daily_orders(
        self, 
        orders: List[StructuredOrder],
        output_path: str,
        order_date: date = None
    ) -> str:
        """ì¼ë³„ ì£¼ë¬¸ì„œ ìƒì„±"""
        
        if order_date is None:
            order_date = date.today()
        
        wb = openpyxl.Workbook()
        
        # 1. ì£¼ë¬¸ ìš”ì•½ ì‹œíŠ¸
        self._create_summary_sheet(wb, orders, order_date)
        
        # 2. ìƒì„¸ ì£¼ë¬¸ ì‹œíŠ¸
        self._create_detail_sheet(wb, orders)
        
        # 3. ë°°ì†¡ ë¼ë²¨ ì‹œíŠ¸
        self._create_shipping_sheet(wb, orders)
        
        # 4. ìƒí’ˆë³„ ì§‘ê³„ ì‹œíŠ¸
        self._create_product_summary_sheet(wb, orders)
        
        # ì €ì¥
        output_file = f"{output_path}/orders_{order_date.strftime('%Y%m%d')}.xlsx"
        wb.save(output_file)
        
        return output_file
    
    def _create_summary_sheet(self, wb, orders: List[StructuredOrder], order_date: date):
        """ì£¼ë¬¸ ìš”ì•½ ì‹œíŠ¸"""
        ws = wb.active
        ws.title = "ì£¼ë¬¸ìš”ì•½"
        
        # í—¤ë”
        ws['A1'] = f"ì£¼ë¬¸ì¼: {order_date.strftime('%Yë…„ %mì›” %dì¼')}"
        ws['A2'] = f"ì´ ì£¼ë¬¸ ê±´ìˆ˜: {len(orders)}ê±´"
        ws['A3'] = f"ì´ ì£¼ë¬¸ ê¸ˆì•¡: {sum(o.total_amount or 0 for o in orders):,}ì›"
        
        # ì±„ë„ë³„ í†µê³„
        ws['A5'] = "ì±„ë„ë³„ ì£¼ë¬¸ í˜„í™©"
        ws['A5'].font = self.header_font
        
        channel_stats = {}
        for order in orders:
            channel_stats[order.channel] = channel_stats.get(order.channel, 0) + 1
        
        row = 6
        for channel, count in channel_stats.items():
            ws[f'A{row}'] = channel
            ws[f'B{row}'] = f"{count}ê±´"
            row += 1
    
    def _create_detail_sheet(self, wb, orders: List[StructuredOrder]):
        """ìƒì„¸ ì£¼ë¬¸ ì‹œíŠ¸"""
        ws = wb.create_sheet("ì£¼ë¬¸ìƒì„¸")
        
        # í—¤ë”
        headers = [
            'ì£¼ë¬¸ë²ˆí˜¸', 'ì£¼ë¬¸ì‹œê°„', 'ì±„ë„', 'ê³ ê°ëª…', 'ì—°ë½ì²˜',
            'ìƒí’ˆëª…', 'ìˆ˜ëŸ‰', 'ë‹¨ê°€', 'ê¸ˆì•¡', 'ì˜µì…˜', 'ìš”ì²­ì‚¬í•­',
            'ë°°ì†¡ì§€', 'ë°°ì†¡í¬ë§ì¼', 'ê²°ì œë°©ì‹', 'ì‹ ë¢°ë„'
        ]
        
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = self.header_font
            cell.fill = self.header_fill
            cell.alignment = Alignment(horizontal='center')
        
        # ë°ì´í„° ì…ë ¥
        row = 2
        for order in orders:
            for item in order.items:
                ws.cell(row=row, column=1, value=order.order_id)
                ws.cell(row=row, column=2, value=order.timestamp.strftime('%H:%M'))
                ws.cell(row=row, column=3, value=order.channel)
                ws.cell(row=row, column=4, value=order.customer_name)
                ws.cell(row=row, column=5, value=order.delivery.phone or '')
                ws.cell(row=row, column=6, value=item.product_name)
                ws.cell(row=row, column=7, value=item.quantity)
                ws.cell(row=row, column=8, value=item.unit_price or 0)
                ws.cell(row=row, column=9, value=(item.unit_price or 0) * item.quantity)
                ws.cell(row=row, column=10, value=', '.join(item.options))
                ws.cell(row=row, column=11, value=item.special_request or '')
                ws.cell(row=row, column=12, value=order.delivery.address or '')
                ws.cell(row=row, column=13, value=order.delivery.delivery_date or '')
                ws.cell(row=row, column=14, value=order.payment.method or '')
                ws.cell(row=row, column=15, value=f"{item.confidence:.0%}")
                
                row += 1
        
        # ì—´ ë„ˆë¹„ ìë™ ì¡°ì •
        for col in range(1, len(headers) + 1):
            ws.column_dimensions[get_column_letter(col)].width = 15
    
    def _create_shipping_sheet(self, wb, orders: List[StructuredOrder]):
        """ë°°ì†¡ ë¼ë²¨ìš© ì‹œíŠ¸"""
        ws = wb.create_sheet("ë°°ì†¡ë¼ë²¨")
        
        headers = ['ì£¼ë¬¸ë²ˆí˜¸', 'ìˆ˜ë ¹ì¸', 'ì—°ë½ì²˜', 'ì£¼ì†Œ', 'ë°°ì†¡ë©”ëª¨', 'ìƒí’ˆë‚´ì—­']
        
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = self.header_font
            cell.fill = self.header_fill
        
        row = 2
        for order in orders:
            items_summary = ', '.join([
                f"{item.product_name} x {item.quantity}" 
                for item in order.items
            ])
            
            ws.cell(row=row, column=1, value=order.order_id)
            ws.cell(row=row, column=2, value=order.delivery.recipient_name or order.customer_name)
            ws.cell(row=row, column=3, value=order.delivery.phone or '')
            ws.cell(row=row, column=4, value=order.delivery.address or '')
            ws.cell(row=row, column=5, value=order.delivery.delivery_memo or '')
            ws.cell(row=row, column=6, value=items_summary)
            
            row += 1
    
    def _create_product_summary_sheet(self, wb, orders: List[StructuredOrder]):
        """ìƒí’ˆë³„ ì§‘ê³„ ì‹œíŠ¸ (ì¤€ë¹„ìš©)"""
        ws = wb.create_sheet("ìƒí’ˆë³„ì§‘ê³„")
        
        # ìƒí’ˆë³„ ìˆ˜ëŸ‰ ì§‘ê³„
        product_totals = {}
        for order in orders:
            for item in order.items:
                key = (item.product_name, item.unit)
                if key not in product_totals:
                    product_totals[key] = {'quantity': 0, 'amount': 0}
                product_totals[key]['quantity'] += item.quantity
                product_totals[key]['amount'] += (item.unit_price or 0) * item.quantity
        
        headers = ['ìƒí’ˆëª…', 'ë‹¨ìœ„', 'ì´ ìˆ˜ëŸ‰', 'ì´ ê¸ˆì•¡']
        for col, header in enumerate(headers, 1):
            cell = ws.cell(row=1, column=col, value=header)
            cell.font = self.header_font
            cell.fill = self.header_fill
        
        row = 2
        for (product_name, unit), totals in sorted(product_totals.items()):
            ws.cell(row=row, column=1, value=product_name)
            ws.cell(row=row, column=2, value=unit)
            ws.cell(row=row, column=3, value=totals['quantity'])
            ws.cell(row=row, column=4, value=totals['amount'])
            row += 1


class GoogleSheetsExporter:
    """êµ¬ê¸€ ì‹œíŠ¸ ì‹¤ì‹œê°„ ì—°ë™"""
    
    def __init__(self, credentials_path: str, spreadsheet_id: str):
        self.creds = Credentials.from_authorized_user_file(credentials_path)
        self.service = build('sheets', 'v4', credentials=self.creds)
        self.spreadsheet_id = spreadsheet_id
    
    async def append_order(self, order: StructuredOrder):
        """ì£¼ë¬¸ ì‹¤ì‹œê°„ ì¶”ê°€"""
        
        values = []
        for item in order.items:
            values.append([
                order.order_id,
                order.timestamp.isoformat(),
                order.channel,
                order.customer_name,
                item.product_name,
                item.quantity,
                item.unit_price or 0,
                order.delivery.address or '',
                order.payment.method or '',
                order.raw_message
            ])
        
        body = {'values': values}
        
        self.service.spreadsheets().values().append(
            spreadsheetId=self.spreadsheet_id,
            range='ì£¼ë¬¸ë‚´ì—­!A:J',
            valueInputOption='USER_ENTERED',
            body=body
        ).execute()

6ë‹¨ê³„: ì „ì²´ íŒŒì´í”„ë¼ì¸ í†µí•©
6.1 ë©”ì¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
python# main_orchestrator.py
import asyncio
from typing import Optional
from datetime import datetime

class OrderProcessingPipeline:
    """
    ì „ì²´ ì£¼ë¬¸ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´í„°
    """
    
    def __init__(self, config: dict):
        # ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”
        self.preprocessor = TextPreprocessor()
        self.product_catalog = ProductCatalog()
        self.extraction_engine = OrderExtractionEngine(
            anthropic_key=config['anthropic_api_key'],
            product_catalog=self.product_catalog
        )
        self.context_manager = CustomerContextManager()
        self.validator = OrderValidator()
        self.pending_manager = PendingOrderManager()
        self.excel_exporter = ExcelOrderExporter()
        self.sheets_exporter = GoogleSheetsExporter(
            credentials_path=config['google_credentials'],
            spreadsheet_id=config['spreadsheet_id']
        )
        
        # ì²˜ë¦¬ í†µê³„
        self.stats = {
            'total_processed': 0,
            'auto_approved': 0,
            'manual_review': 0,
            'failed': 0
        }
    
    async def process_message(self, message: RawMessage) -> Optional[StructuredOrder]:
        """
        ë‹¨ì¼ ë©”ì‹œì§€ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸
        """
        
        try:
            # 1. ì „ì²˜ë¦¬
            preprocessed = self.preprocessor.preprocess(message.content)
            message.content = preprocessed['processed']
            
            # 2. ê³ ê° ì»¨í…ìŠ¤íŠ¸ ì¡°íšŒ
            customer_context = await self.context_manager.get_customer_context(
                message.sender_id
            )
            
            # 3. ë§¥ë½ ì˜ì¡´ í‘œí˜„ í•´ì„
            if any(kw in message.content for kw in ['ì €ë²ˆ', 'í‰ì†Œ', 'ëŠ˜', 'ê·¸ê±°']):
                resolved = await self.context_manager.resolve_reference(
                    message.content,
                    message.sender_id
                )
                if resolved:
                    message.context_messages.append(f"[ë§¥ë½ í•´ì„]: {resolved}")
            
            # 4. LLM ê¸°ë°˜ ì •í˜•í™”
            order = await self.extraction_engine.extract_order(
                message=message,
                customer_history=customer_context.get('recent_orders')
            )
            
            # 5. ê²€ì¦
            validation = self.validator.validate(order)
            
            # 6. ì²˜ë¦¬ ë¶„ê¸°
            if validation.requires_human_review:
                # ìˆ˜ë™ í™•ì¸ í•„ìš”
                await self.pending_manager.add_pending_order(order, validation)
                self.stats['manual_review'] += 1
                return None  # ì•„ì§ í™•ì •ë˜ì§€ ì•ŠìŒ
            else:
                # ìë™ ìŠ¹ì¸
                await self._finalize_order(order)
                self.stats['auto_approved'] += 1
                return order
        
        except Exception as e:
            self.stats['failed'] += 1
            # ì—ëŸ¬ ë¡œê¹… ë° ìˆ˜ë™ ì²˜ë¦¬ íë¡œ ì „ì†¡
            await self._handle_error(message, e)
            return None
        
        finally:
            self.stats['total_processed'] += 1
    
    async def _finalize_order(self, order: StructuredOrder):
        """ì£¼ë¬¸ í™•ì • ì²˜ë¦¬"""
        
        # 1. êµ¬ê¸€ì‹œíŠ¸ ì‹¤ì‹œê°„ ì¶”ê°€
        await self.sheets_exporter.append_order(order)
        
        # 2. ê³ ê° ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
        await self.context_manager.update_customer_context(
            order.customer_id,
            order
        )
        
        # 3. ì•Œë¦¼ ë°œì†¡ (í•„ìš”ì‹œ)
        # await self.notification_service.send_order_confirmation(order)
    
    async def generate_daily_report(self, target_date: date = None):
        """ì¼ì¼ ì£¼ë¬¸ì„œ ìƒì„±"""
        
        # ë‹¹ì¼ í™•ì •ëœ ì£¼ë¬¸ ì¡°íšŒ
        orders = await self._get_confirmed_orders(target_date)
        
        # ì—‘ì…€ íŒŒì¼ ìƒì„±
        excel_path = self.excel_exporter.export_daily_orders(
            orders=orders,
            output_path='./reports',
            order_date=target_date
        )
        
        return excel_path
    
    async def run(self):
        """ë©”ì‹œì§€ í ì†Œë¹„ ë° ì²˜ë¦¬ ë£¨í”„"""
        
        consumer = KafkaConsumer(
            'raw-orders',
            bootstrap_servers=['localhost:9092'],
            value_deserializer=lambda m: json.loads(m.decode('utf-8'))
        )
        
        for message in consumer:
            raw_message = RawMessage(**message.value)
            await self.process_message(raw_message)


# ì‹¤í–‰
if __name__ == "__main__":
    config = {
        'anthropic_api_key': 'your-api-key',
        'google_credentials': './credentials.json',
        'spreadsheet_id': 'your-spreadsheet-id'
    }
    
    pipeline = OrderProcessingPipeline(config)
    asyncio.run(pipeline.run())

7ë‹¨ê³„: ì„±ëŠ¥ ìµœì í™” ë° í•™ìŠµ
7.1 í”¼ë“œë°± ë£¨í”„ í•™ìŠµ ì‹œìŠ¤í…œ
python# feedback_learning.py
from typing import Dict, List, Tuple
import json

class FeedbackLearningSystem:
    """
    íŒë§¤ì ìˆ˜ì • í”¼ë“œë°± ê¸°ë°˜ í•™ìŠµ
    - ì˜¤ì¸ì‹ íŒ¨í„´ ìˆ˜ì§‘
    - í”„ë¡¬í”„íŠ¸ ìë™ ê°œì„ 
    - ìƒí’ˆ ë™ì˜ì–´ ì‚¬ì „ í™•ì¥
    """
    
    def __init__(self):
        self.correction_log: List[Dict] = []
        self.synonym_suggestions: Dict[str, List[str]] = {}
    
    async def record_correction(
        self, 
        original_extraction: StructuredOrder,
        corrected_order: StructuredOrder,
        correction_type: str
    ):
        """ìˆ˜ì • ë‚´ì—­ ê¸°ë¡"""
        
        correction = {
            'timestamp': datetime.now().isoformat(),
            'original': original_extraction.dict(),
            'corrected': corrected_order.dict(),
            'type': correction_type,
            'differences': self._find_differences(original_extraction, corrected_order)
        }
        
        self.correction_log.append(correction)
        
        # ë™ì˜ì–´ í•™ìŠµ
        await self._learn_synonyms(correction['differences'])
    
    def _find_differences(
        self, 
        original: StructuredOrder, 
        corrected: StructuredOrder
    ) -> List[Dict]:
        """ì›ë³¸ê³¼ ìˆ˜ì •ë³¸ì˜ ì°¨ì´ ë¶„ì„"""
        
        differences = []
        
        for i, (orig_item, corr_item) in enumerate(zip(original.items, corrected.items)):
            if orig_item.product_name != corr_item.product_name:
                differences.append({
                    'field': 'product_name',
                    'original': orig_item.product_name,
                    'corrected': corr_item.product_name,
                    'item_index': i
                })
            if orig_item.quantity != corr_item.quantity:
                differences.append({
                    'field': 'quantity',
                    'original': orig_item.quantity,
                    'corrected': corr_item.quantity,
                    'item_index': i
                })
        
        return differences
    
    async def _learn_synonyms(self, differences: List[Dict]):
        """ë™ì˜ì–´/ë³€í˜• í‘œí˜„ í•™ìŠµ"""
        
        for diff in differences:
            if diff['field'] == 'product_name':
                original = diff['original']
                corrected = diff['corrected']
                
                if corrected not in self.synonym_suggestions:
                    self.synonym_suggestions[corrected] = []
                
                if original not in self.synonym_suggestions[corrected]:
                    self.synonym_suggestions[corrected].append(original)
    
    def get_improved_prompt_context(self) -> str:
        """í•™ìŠµëœ ë‚´ìš©ì„ í”„ë¡¬í”„íŠ¸ì— ë°˜ì˜"""
        
        # ìì£¼ ë°œìƒí•˜ëŠ” ì˜¤ì¸ì‹ íŒ¨í„´
        common_mistakes = self._analyze_common_mistakes()
        
        context = "## ìì£¼ ë°œìƒí•˜ëŠ” ì˜¤ì¸ì‹ ì£¼ì˜ì‚¬í•­\n"
        for mistake in common_mistakes[:10]:
            context += f"- '{mistake['original']}' â†’ '{mistake['corrected']}' (ë°œìƒ {mistake['count']}íšŒ)\n"
        
        context += "\n## ë™ì˜ì–´/ë³€í˜• í‘œí˜„ ì‚¬ì „\n"
        for product, synonyms in list(self.synonym_suggestions.items())[:20]:
            context += f"- {product}: {', '.join(synonyms)}\n"
        
        return context
    
    def _analyze_common_mistakes(self) -> List[Dict]:
        """ë¹ˆë²ˆí•œ ì˜¤ì¸ì‹ íŒ¨í„´ ë¶„ì„"""
        
        mistake_counts = {}
        
        for correction in self.correction_log:
            for diff in correction['differences']:
                if diff['field'] == 'product_name':
                    key = (diff['original'], diff['corrected'])
                    mistake_counts[key] = mistake_counts.get(key, 0) + 1
        
        sorted_mistakes = sorted(
            mistake_counts.items(), 
            key=lambda x: x[1], 
            reverse=True
        )
        
        return [
            {'original': k[0], 'corrected': k[1], 'count': v}
            for k, v in sorted_mistakes
        ]

ì˜ˆìƒ ì„±ëŠ¥ ì§€í‘œ
ì§€í‘œëª©í‘œê°’ì„¤ëª…ìë™ ì²˜ë¦¬ìœ¨70-80%ìˆ˜ë™ í™•ì¸ ì—†ì´ ìë™ ìŠ¹ì¸ì •í™•ë„ (ìë™ ì²˜ë¦¬)95%+ìë™ ìŠ¹ì¸ëœ ì£¼ë¬¸ì˜ ì •í™•ë„ì²˜ë¦¬ ì‹œê°„2-5ì´ˆë©”ì‹œì§€ ìˆ˜ì‹  â†’ ì •í˜•í™” ì™„ë£Œì¼ì¼ ì²˜ë¦¬ëŸ‰10,000ê±´+ë‹¨ì¼ ì„œë²„ ê¸°ì¤€

êµ¬í˜„ ìš°ì„ ìˆœìœ„

1ë‹¨ê³„ (MVP): LLM ì¶”ì¶œ ì—”ì§„ + ì—‘ì…€ ì¶œë ¥
2ë‹¨ê³„: íŒë§¤ì í™•ì¸ ëŒ€ì‹œë³´ë“œ + ì‹¤ì‹œê°„ ì•Œë¦¼
3ë‹¨ê³„: ë©€í‹°ì±„ë„ ìˆ˜ì§‘ + RAG ìƒí’ˆ ë§¤ì¹­
4ë‹¨ê³„: í”¼ë“œë°± í•™ìŠµ + ì„±ëŠ¥ ìµœì í™”

ì´ ì„¤ê³„ë¡œ êµ¬í˜„í•˜ë©´ ë¹„ì •í˜• ì¹´ì¹´ì˜¤í†¡ ì£¼ë¬¸ì˜ 70-80%ë¥¼ ìë™ ì²˜ë¦¬í•  ìˆ˜ ìˆì„ ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤.êµ¬í˜„ì„ í•˜ê¸° ìœ„í•´ ë‚´ê°€ í•´ì•¼ í•  ì—­í• ê³¼ 
ì—…ë¬´ ìˆœì„œ ëª©ë¡  ì‘ì„±12ì›” 18ì¼êµ¬í˜„ì„ ìœ„í•œ ì—­í• ê³¼ ì—…ë¬´ ìˆœì„œë¥¼ ì •ë¦¬í•´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

í”„ë¡œì íŠ¸ ê°œìš”
ëª©í‘œ: ì¹´ì¹´ì˜¤í†¡ ë¹„ì •í˜• ì£¼ë¬¸ â†’ ì •í˜•í™” â†’ ì—‘ì…€ ìë™í™” ì‹œìŠ¤í…œ êµ¬ì¶•
ì˜ˆìƒ ê¸°ê°„: 8-12ì£¼ (MVP ê¸°ì¤€)
ì˜ˆìƒ ë¹„ìš©: ì›” 50-200ë§Œì› (API ë¹„ìš© + ì¸í”„ë¼)

ë‹¹ì‹ ì´ í•´ì•¼ í•  ì—­í• 
ì—­í•  1: í”„ë¡œì íŠ¸ ë§¤ë‹ˆì € (PM)

ìš”êµ¬ì‚¬í•­ ì •ì˜ ë° ìš°ì„ ìˆœìœ„ ê²°ì •
ì¼ì • ê´€ë¦¬ ë° ë§ˆì¼ìŠ¤í†¤ ì„¤ì •
ì™¸ë¶€ í˜‘ë ¥ì‚¬/ê°œë°œì ê´€ë¦¬ (í•„ìš”ì‹œ)

ì—­í•  2: ë„ë©”ì¸ ì „ë¬¸ê°€

ì‹¤ì œ ì£¼ë¬¸ ë°ì´í„° ì œê³µ ë° ë¶„ì„
ìƒí’ˆ ì¹´íƒˆë¡œê·¸ ì •ë¦¬
ì •í˜•í™” ê·œì¹™ ì •ì˜
í…ŒìŠ¤íŠ¸ ë° ê²€ì¦

ì—­í•  3: ê°œë°œì (ì§ì ‘ ë˜ëŠ” ì™¸ì£¼)

ì‹œìŠ¤í…œ ì„¤ê³„ ë° êµ¬í˜„
API ì—°ë™
í…ŒìŠ¤íŠ¸ ë° ë°°í¬


ì—…ë¬´ ìˆœì„œ ëª©ë¡
Phase 0: ì¤€ë¹„ ë‹¨ê³„ (1ì£¼)
ìˆœë²ˆì—…ë¬´ìƒì„¸ ë‚´ìš©ì‚°ì¶œë¬¼ì˜ˆìƒ ì‹œê°„0-1í˜„í™© ë¶„ì„í˜„ì¬ ì£¼ë¬¸ ì²˜ë¦¬ í”„ë¡œì„¸ìŠ¤ ë¬¸ì„œí™”í˜„í™© ë¶„ì„ì„œ2ì‹œê°„0-2ìƒ˜í”Œ ë°ì´í„° ìˆ˜ì§‘ìµœê·¼ 1ê°œì›” ì¹´ì¹´ì˜¤í†¡ ì£¼ë¬¸ ë©”ì‹œì§€ 100-500ê±´ ìˆ˜ì§‘ì£¼ë¬¸ ë©”ì‹œì§€ CSV3ì‹œê°„0-3ìƒí’ˆ ì¹´íƒˆë¡œê·¸ ì •ë¦¬íŒë§¤ ìƒí’ˆ ëª©ë¡ (ìƒí’ˆëª…, ê°€ê²©, ë‹¨ìœ„, ì˜µì…˜)ìƒí’ˆ ë§ˆìŠ¤í„° ì—‘ì…€4ì‹œê°„0-4ìš”êµ¬ì‚¬í•­ ì •ì˜í•„ìˆ˜ ê¸°ëŠ¥ vs ì„ íƒ ê¸°ëŠ¥ êµ¬ë¶„ìš”êµ¬ì‚¬í•­ ëª…ì„¸ì„œ2ì‹œê°„0-5ì˜ˆì‚°/ì¼ì • í™•ì •ê°œë°œ ë°©ì‹ ê²°ì • (ì§ì ‘/ì™¸ì£¼/SaaS)í”„ë¡œì íŠ¸ ê³„íšì„œ2ì‹œê°„
ì²´í¬ë¦¬ìŠ¤íŠ¸ 0-2: ìƒ˜í”Œ ë°ì´í„° ìˆ˜ì§‘ í˜•ì‹
[ìˆ˜ì§‘í•  ì •ë³´]
- ì›ë³¸ ë©”ì‹œì§€ í…ìŠ¤íŠ¸
- ë°œì‹ ì (ì´ë¦„ ë˜ëŠ” ID)
- ìˆ˜ì‹  ì±„ë„ (ì¹´ì¹´ì˜¤í†¡/ë°´ë“œ/ì¸ìŠ¤íƒ€ ë“±)
- ìˆ˜ì‹  ì‹œê°„
- ì‹¤ì œ ì²˜ë¦¬ëœ ì£¼ë¬¸ ë‚´ìš© (ì •ë‹µ ë°ì´í„°)
ì²´í¬ë¦¬ìŠ¤íŠ¸ 0-3: ìƒí’ˆ ì¹´íƒˆë¡œê·¸ í˜•ì‹
ìƒí’ˆì½”ë“œìƒí’ˆëª…ì¹´í…Œê³ ë¦¬ë‹¨ê°€ë‹¨ìœ„ì˜µì…˜ë™ì˜ì–´/ë³„ì¹­P001ê¹€ì¹˜ì°Œê°œì°Œê°œë¥˜8000ì¸ë¶„ë§µê¸°(ìˆœí•œë§›/ë³´í†µ/ë§¤ìš´ë§›)ê¹€ì°Œ, ê¹€ì¹˜ì°Œê²ŒP002ì œìœ¡ë³¶ìŒë³¶ìŒë¥˜12000ì¸ë¶„ë§µê¸°, ì–‘(ì†Œ/ì¤‘/ëŒ€)ì¬ìœ¡, ì œìœ¡

Phase 1: í™˜ê²½ êµ¬ì¶• (1ì£¼)
ìˆœë²ˆì—…ë¬´ìƒì„¸ ë‚´ìš©ì‚°ì¶œë¬¼ì˜ˆìƒ ì‹œê°„1-1ê°œë°œ í™˜ê²½ ì„¤ì •Python 3.10+, ê°€ìƒí™˜ê²½ êµ¬ì„±ê°œë°œ í™˜ê²½2ì‹œê°„1-2API í‚¤ ë°œê¸‰Anthropic Claude API ê°€ì… ë° í‚¤ ë°œê¸‰API í‚¤1ì‹œê°„1-3í´ë¼ìš°ë“œ ê³„ì •AWS/GCP ê³„ì • ìƒì„± (í•„ìš”ì‹œ)í´ë¼ìš°ë“œ ê³„ì •1ì‹œê°„1-4ì €ì¥ì†Œ ì„¤ì •GitHub ë ˆí¬ì§€í† ë¦¬ ìƒì„±Git ì €ì¥ì†Œ30ë¶„1-5ê¸°ë³¸ íŒ¨í‚¤ì§€ ì„¤ì¹˜í•„ìˆ˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜requirements.txt1ì‹œê°„
ì²´í¬ë¦¬ìŠ¤íŠ¸ 1-5: í•„ìˆ˜ íŒ¨í‚¤ì§€
bash# requirements.txt
anthropic>=0.18.0      # Claude API
openai>=1.0.0          # GPT API (ë°±ì—…ìš©)
pandas>=2.0.0          # ë°ì´í„° ì²˜ë¦¬
openpyxl>=3.1.0        # ì—‘ì…€ ìƒì„±
pydantic>=2.0.0        # ë°ì´í„° ê²€ì¦
fastapi>=0.100.0       # API ì„œë²„
uvicorn>=0.23.0        # ASGI ì„œë²„
redis>=4.5.0           # ìºì‹±/ì„¸ì…˜
sentence-transformers>=2.2.0  # ì„ë² ë”©
chromadb>=0.4.0        # ë²¡í„° DB
konlpy>=0.6.0          # í•œêµ­ì–´ í˜•íƒœì†Œ
pykospacing>=0.5       # ë„ì–´ì“°ê¸° êµì •
```

---

### Phase 2: í•µì‹¬ ì—”ì§„ ê°œë°œ (3-4ì£¼)

#### Week 1: ì „ì²˜ë¦¬ ëª¨ë“ˆ

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 2-1 | í…ìŠ¤íŠ¸ ì •ê·œí™” | ì˜¤íƒ€/ë„ì–´ì“°ê¸°/íŠ¹ìˆ˜ë¬¸ì ì²˜ë¦¬ | preprocessor.py | 8ì‹œê°„ |
| 2-2 | ì˜¤íƒ€ ì‚¬ì „ êµ¬ì¶• | ìƒ˜í”Œ ë°ì´í„° ê¸°ë°˜ ì˜¤íƒ€-ì •ë‹µ ë§¤í•‘ | typo_dict.json | 4ì‹œê°„ |
| 2-3 | ìˆ˜ëŸ‰ í‘œí˜„ ì •ê·œí™” | "í•œ ê°œ", "ë‘ë°•ìŠ¤" â†’ "1ê°œ", "2ë°•ìŠ¤" | quantity_parser.py | 4ì‹œê°„ |
| 2-4 | ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ | ì „ì²˜ë¦¬ ëª¨ë“ˆ í…ŒìŠ¤íŠ¸ | test_preprocessor.py | 2ì‹œê°„ |

#### Week 2: LLM ì¶”ì¶œ ì—”ì§„

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 2-5 | ë°ì´í„° ìŠ¤í‚¤ë§ˆ ì •ì˜ | Pydantic ëª¨ë¸ (OrderItem, StructuredOrder ë“±) | schemas.py | 4ì‹œê°„ |
| 2-6 | í”„ë¡¬í”„íŠ¸ ì„¤ê³„ | ì¶”ì¶œìš© ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ì‘ì„± | prompts.py | 8ì‹œê°„ |
| 2-7 | Claude API ì—°ë™ | Structured Output í™œìš© ì¶”ì¶œ | extraction_engine.py | 8ì‹œê°„ |
| 2-8 | í”„ë¡¬í”„íŠ¸ íŠœë‹ | ìƒ˜í”Œ ë°ì´í„°ë¡œ í”„ë¡¬í”„íŠ¸ ìµœì í™” | - | 8ì‹œê°„ |

#### Week 3: ìƒí’ˆ ë§¤ì¹­ (RAG)

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 2-9 | ì„ë² ë”© ëª¨ë¸ ì„ ì • | í•œêµ­ì–´ ì„ë² ë”© ëª¨ë¸ í…ŒìŠ¤íŠ¸ | - | 2ì‹œê°„ |
| 2-10 | ë²¡í„° DB êµ¬ì¶• | ìƒí’ˆ ì¹´íƒˆë¡œê·¸ ì„ë² ë”© ë° ì €ì¥ | product_catalog.py | 6ì‹œê°„ |
| 2-11 | ìœ ì‚¬ ìƒí’ˆ ê²€ìƒ‰ | ì˜¤íƒ€/ë³€í˜•ì—ë„ ë§¤ì¹­ë˜ëŠ” ê²€ìƒ‰ | - | 4ì‹œê°„ |
| 2-12 | ë§¤ì¹­ ì •í™•ë„ í…ŒìŠ¤íŠ¸ | ìƒ˜í”Œ ë°ì´í„°ë¡œ ë§¤ì¹­ë¥  ì¸¡ì • | í…ŒìŠ¤íŠ¸ ë¦¬í¬íŠ¸ | 4ì‹œê°„ |

#### Week 4: ê²€ì¦ ë° í†µí•©

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 2-13 | ê²€ì¦ ë¡œì§ ê°œë°œ | ì‹ ë¢°ë„ í‰ê°€, í•„ìˆ˜í•„ë“œ ê²€ì¦ | validator.py | 6ì‹œê°„ |
| 2-14 | íŒŒì´í”„ë¼ì¸ í†µí•© | ì „ì²˜ë¦¬â†’ì¶”ì¶œâ†’ê²€ì¦ ì—°ê²° | pipeline.py | 4ì‹œê°„ |
| 2-15 | í†µí•© í…ŒìŠ¤íŠ¸ | End-to-End í…ŒìŠ¤íŠ¸ | test_pipeline.py | 6ì‹œê°„ |
| 2-16 | ì„±ëŠ¥ ì¸¡ì • | ì •í™•ë„, ì²˜ë¦¬ ì‹œê°„ ì¸¡ì • | ì„±ëŠ¥ ë¦¬í¬íŠ¸ | 4ì‹œê°„ |

---

### Phase 3: ì—‘ì…€ ìë™í™” (1-2ì£¼)

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 3-1 | ì—‘ì…€ í…œí”Œë¦¿ ì„¤ê³„ | ì£¼ë¬¸ì„œ ì–‘ì‹ ê²°ì • | í…œí”Œë¦¿.xlsx | 2ì‹œê°„ |
| 3-2 | ì—‘ì…€ ìƒì„± ëª¨ë“ˆ | openpyxl ê¸°ë°˜ ìë™ ìƒì„± | excel_exporter.py | 8ì‹œê°„ |
| 3-3 | ì‹œíŠ¸ë³„ ê¸°ëŠ¥ êµ¬í˜„ | ìš”ì•½/ìƒì„¸/ë°°ì†¡/ì§‘ê³„ ì‹œíŠ¸ | - | 6ì‹œê°„ |
| 3-4 | êµ¬ê¸€ì‹œíŠ¸ ì—°ë™ (ì„ íƒ) | ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ | sheets_exporter.py | 6ì‹œê°„ |
| 3-5 | ì¶œë ¥ í…ŒìŠ¤íŠ¸ | ì‹¤ì œ ì£¼ë¬¸ìœ¼ë¡œ ì—‘ì…€ ìƒì„± í…ŒìŠ¤íŠ¸ | í…ŒìŠ¤íŠ¸ ì—‘ì…€ | 2ì‹œê°„ |

---

### Phase 4: ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ (2ì£¼)

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 4-1 | API ì„œë²„ êµ¬ì¶• | FastAPI ê¸°ë°˜ REST API | main.py | 8ì‹œê°„ |
| 4-2 | í™•ì¸ ëŒ€ì‹œë³´ë“œ | ë¯¸í™•ì¸ ì£¼ë¬¸ ëª©ë¡/ìˆ˜ì •/ìŠ¹ì¸ UI | dashboard/ | 16ì‹œê°„ |
| 4-3 | ì‹¤ì‹œê°„ ì•Œë¦¼ | WebSocket ê¸°ë°˜ ìƒˆ ì£¼ë¬¸ ì•Œë¦¼ | websocket.py | 6ì‹œê°„ |
| 4-4 | ëª¨ë°”ì¼ ëŒ€ì‘ | ë°˜ì‘í˜• UI ë˜ëŠ” ì¹´ì¹´ì˜¤í†¡ ì•Œë¦¼ | - | 4ì‹œê°„ |
| 4-5 | ì‚¬ìš©ì í…ŒìŠ¤íŠ¸ | ì‹¤ì œ ì‚¬ìš© ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ | í”¼ë“œë°± ì •ë¦¬ | 4ì‹œê°„ |

---

### Phase 5: ë©”ì‹œì§€ ìˆ˜ì§‘ ì—°ë™ (1-2ì£¼)

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 5-1 | ì¹´ì¹´ì˜¤í†¡ ì±„ë„ ì—°ë™ | ì¹´ì¹´ì˜¤ ë¹„ì¦ˆë‹ˆìŠ¤ API ì„¤ì • | kakao_connector.py | 8ì‹œê°„ |
| 5-2 | ìˆ˜ë™ ì…ë ¥ ì¸í„°í˜ì´ìŠ¤ | ë³µì‚¬/ë¶™ì—¬ë„£ê¸°ë¡œ ë©”ì‹œì§€ ì…ë ¥ | manual_input.py | 4ì‹œê°„ |
| 5-3 | ë°´ë“œ/ì¸ìŠ¤íƒ€ ì—°ë™ (ì„ íƒ) | ì¶”ê°€ ì±„ë„ ì»¤ë„¥í„° | connectors/ | 8ì‹œê°„ |
| 5-4 | ë©”ì‹œì§€ í ì„¤ì • | Redis ë˜ëŠ” ê°„ë‹¨í•œ í | queue.py | 4ì‹œê°„ |

---

### Phase 6: ë°°í¬ ë° ìš´ì˜ (1ì£¼)

| ìˆœë²ˆ | ì—…ë¬´ | ìƒì„¸ ë‚´ìš© | ì‚°ì¶œë¬¼ | ì˜ˆìƒ ì‹œê°„ |
|------|------|----------|--------|----------|
| 6-1 | ì„œë²„ ë°°í¬ | AWS/GCP ë˜ëŠ” ë¡œì»¬ ì„œë²„ | ë°°í¬ í™˜ê²½ | 6ì‹œê°„ |
| 6-2 | ëª¨ë‹ˆí„°ë§ ì„¤ì • | ì—ëŸ¬ ì•Œë¦¼, ì²˜ë¦¬ëŸ‰ ëª¨ë‹ˆí„°ë§ | ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ | 4ì‹œê°„ |
| 6-3 | ë°±ì—… ì„¤ì • | ë°ì´í„° ë°±ì—… ìë™í™” | ë°±ì—… ìŠ¤í¬ë¦½íŠ¸ | 2ì‹œê°„ |
| 6-4 | ìš´ì˜ ë§¤ë‰´ì–¼ ì‘ì„± | ì‚¬ìš©ë²•, ë¬¸ì œ í•´ê²° ê°€ì´ë“œ | ìš´ì˜ ë§¤ë‰´ì–¼.md | 4ì‹œê°„ |
| 6-5 | ì‹¤ì„œë¹„ìŠ¤ ì „í™˜ | íŒŒì¼ëŸ¿ ìš´ì˜ â†’ ì „ì²´ ì „í™˜ | - | ì§€ì† |

---

## ì¦‰ì‹œ ì‹œì‘í•  ì•¡ì…˜ ì•„ì´í…œ

### ì´ë²ˆ ì£¼ í•  ì¼ (ìš°ì„ ìˆœìœ„ìˆœ)
```
â–¡ 1. ìƒ˜í”Œ ì£¼ë¬¸ ë©”ì‹œì§€ 100ê±´ ì´ìƒ ìˆ˜ì§‘ (ì—‘ì…€/CSV)
   - ì¹´ì¹´ì˜¤í†¡ ëŒ€í™” ë‚´ë³´ë‚´ê¸° ë˜ëŠ” ìº¡ì²˜
   - ê° ë©”ì‹œì§€ì— ëŒ€í•œ "ì •ë‹µ" ì£¼ë¬¸ ë‚´ìš© ê¸°ë¡

â–¡ 2. ìƒí’ˆ ì¹´íƒˆë¡œê·¸ ì—‘ì…€ ì‘ì„±
   - ìƒí’ˆëª…, ê°€ê²©, ë‹¨ìœ„, ì˜µì…˜
   - ìì£¼ ì‚¬ìš©ë˜ëŠ” ë³„ì¹­/ì˜¤íƒ€ í¬í•¨

â–¡ 3. Anthropic API ê°€ì… ë° í‚¤ ë°œê¸‰
   - https://console.anthropic.com
   - ê²°ì œ ìˆ˜ë‹¨ ë“±ë¡ (ì›” $20 ì •ë„ ì˜ˆìƒ)

â–¡ 4. ê°œë°œ í™˜ê²½ ê²°ì •
   - ì§ì ‘ ê°œë°œ: Python ì„¤ì¹˜, VSCode ì„¤ì •
   - ì™¸ì£¼ ê°œë°œ: ê°œë°œì ì„­ì™¸, ìš”êµ¬ì‚¬í•­ ì „ë‹¬
   - SaaS í™œìš©: ê¸°ì¡´ ì„œë¹„ìŠ¤ ê²€í†  (Zapier, Make ë“±)

â–¡ 5. MVP ë²”ìœ„ í™•ì •
   - 1ì°¨: ìˆ˜ë™ ì…ë ¥ â†’ ì •í˜•í™” â†’ ì—‘ì…€ ì¶œë ¥
   - 2ì°¨: ì¹´ì¹´ì˜¤í†¡ ìë™ ìˆ˜ì§‘ ì¶”ê°€
   - 3ì°¨: í™•ì¸ ëŒ€ì‹œë³´ë“œ ì¶”ê°€

ê°œë°œ ë°©ì‹ ì„ íƒ ê°€ì´ë“œ
ì˜µì…˜ A: ì§ì ‘ ê°œë°œ (Python ê¸°ë³¸ ì§€ì‹ í•„ìš”)
ì¥ì : ë¹„ìš© ìµœì†Œ, ì™„ì „í•œ ì»¤ìŠ¤í„°ë§ˆì´ì§•
ë‹¨ì : ì‹œê°„ ì†Œìš”, ê¸°ìˆ  í•™ìŠµ í•„ìš”
ì˜ˆìƒ ë¹„ìš©: ì›” 5-20ë§Œì› (API ë¹„ìš©ë§Œ)
ì¶”ì²œ ëŒ€ìƒ: ê°œë°œ ê²½í—˜ ìˆê±°ë‚˜ í•™ìŠµ ì˜ì§€ ìˆëŠ” ê²½ìš°
ì˜µì…˜ B: ì™¸ì£¼ ê°œë°œ
ì¥ì : ë¹ ë¥¸ êµ¬í˜„, ì „ë¬¸ì„±
ë‹¨ì : ë¹„ìš©, ì˜ì¡´ì„±
ì˜ˆìƒ ë¹„ìš©: 500-2000ë§Œì› (ì¼íšŒì„±) + ìœ ì§€ë³´ìˆ˜
ì¶”ì²œ ëŒ€ìƒ: ì˜ˆì‚° ìˆê³  ë¹ ë¥¸ êµ¬í˜„ í•„ìš”í•œ ê²½ìš°
ì˜µì…˜ C: ë…¸ì½”ë“œ/ë¡œìš°ì½”ë“œ (Zapier + GPT)
ì¥ì : ë¹ ë¥¸ ì‹œì‘, ì½”ë”© ë¶ˆí•„ìš”
ë‹¨ì : ì œí•œëœ ì»¤ìŠ¤í„°ë§ˆì´ì§•, ì›” ë¹„ìš©
ì˜ˆìƒ ë¹„ìš©: ì›” 10-50ë§Œì›
ì¶”ì²œ ëŒ€ìƒ: ë¹ ë¥¸ ê²€ì¦ ì›í•˜ëŠ” ê²½ìš°

ë‹¤ìŒ ë‹¨ê³„
ì–´ë–¤ ê°œë°œ ë°©ì‹ì„ ì„ íƒí•˜ì…¨ë‚˜ìš”? ì„ íƒì— ë”°ë¼ ë‹¤ìŒì„ ì œê³µí•´ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

ì§ì ‘ ê°œë°œ: ìƒì„¸ ì½”ë“œ + ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ
ì™¸ì£¼ ê°œë°œ: ê°œë°œììš© ìƒì„¸ ëª…ì„¸ì„œ + ê³„ì•½ ì²´í¬ë¦¬ìŠ¤íŠ¸
ë…¸ì½”ë“œ: Zapier/Make ì›Œí¬í”Œë¡œìš° ì„¤ê³„
ì›¹ìƒì—ì„œ ìƒ˜í”Œ ì£¼ë¬¸ ë©”ì‹œì§€ 100ê±´ ì´ìƒ ìˆ˜ì§‘ (ì—‘ì…€/CSV) ê°€ëŠ¥í•´?12ì›” 18ì¼ì›¹ìƒì—ì„œ ì‹¤ì œ ì‹í’ˆ ì£¼ë¬¸ ë¬¸ì ë©”ì‹œì§€ ìƒ˜í”Œì„ ìˆ˜ì§‘í•˜ëŠ” ê²ƒì€ ì–´ë µìŠµë‹ˆë‹¤.
í˜„ì‹¤ì ì¸ ë¬¸ì œ
ê°œì¸ì •ë³´ ì´ìŠˆ: ì‹¤ì œ ì£¼ë¬¸ ë©”ì‹œì§€ëŠ” ê³ ê° ì´ë¦„, ì—°ë½ì²˜, ì£¼ì†Œê°€ í¬í•¨ë˜ì–´ ìˆì–´ ê³µê°œëœ ë°ì´í„°ê°€ ê±°ì˜ ì—†ìŠµë‹ˆë‹¤.
ê²€ìƒ‰ ê²°ê³¼: ì»¤ë®¤ë‹ˆí‹°ë‚˜ ë¸”ë¡œê·¸ì— ì˜¬ë¼ì˜¨ ì£¼ë¬¸ ê´€ë ¨ ê¸€ì€ ëŒ€ë¶€ë¶„ "ì´ë ‡ê²Œ ì£¼ë¬¸í–ˆë‹¤"ëŠ” í›„ê¸° í˜•íƒœì´ì§€, ì›ë³¸ ë©”ì‹œì§€ ê·¸ëŒ€ë¡œëŠ” ì•„ë‹™ë‹ˆë‹¤.

ëŒ€ì•ˆ ë°©ë²•
1. ì§ì ‘ ë³´ìœ  ë°ì´í„° í™œìš© (ê°€ì¥ ì¶”ì²œ)
ë³¸ì¸ì´ ìš´ì˜í•˜ê±°ë‚˜ í˜‘ë ¥í•˜ëŠ” íŒë§¤ìì˜ ì‹¤ì œ ì£¼ë¬¸ ë©”ì‹œì§€ê°€ ê°€ì¥ ì¢‹ìŠµë‹ˆë‹¤. ì‹¤ì œ íŒ¨í„´ì„ ë°˜ì˜í•˜ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.
2. í•©ì„± ë°ì´í„° ìƒì„±
ì œê°€ í˜„ì‹¤ì ì¸ ì£¼ë¬¸ ë©”ì‹œì§€ ìƒ˜í”Œ 100ê±´ì„ ìƒì„±í•´ë“œë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì •ë³´ë¥¼ ì•Œë ¤ì£¼ì‹œë©´ ë” ì •í™•í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤:

íŒë§¤ ìƒí’ˆ ì¢…ë¥˜ (ë°˜ì°¬, ë†ì‚°ë¬¼, ê°€ê³µì‹í’ˆ ë“±)
ì£¼ìš” ê³ ê°ì¸µ (ì—°ë ¹ëŒ€, ì§€ì—­)
ìì£¼ ì‚¬ìš©ë˜ëŠ” ì˜µì…˜ (ë§µê¸°, í¬ê¸° ë“±)
ì‹¤ì œ ë°›ì•„ë³¸ ì£¼ë¬¸ ë©”ì‹œì§€ ì˜ˆì‹œ 3-5ê°œ

3. ì»¤ë®¤ë‹ˆí‹° íŒ¨í„´ ì°¸ê³ 
ì‹í’ˆ íŒë§¤ì ì»¤ë®¤ë‹ˆí‹°(ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´ ì¹´í˜, ë°°ë¯¼ì…€ëŸ¬ ì¹´í˜ ë“±)ì—ì„œ ì£¼ë¬¸ ê´€ë ¨ ê³ ì¶© ê¸€ì„ ì°¸ê³ í•˜ì—¬ íŒ¨í„´ì„ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í•©ì„± ë°ì´í„° 100ê±´ì„ ìƒì„±í•´ë“œë¦´ê¹Œìš”? íŒë§¤í•˜ì‹œëŠ” ìƒí’ˆ ì¢…ë¥˜ì™€ ì˜ˆì‹œ ë©”ì‹œì§€ ëª‡ ê°œë§Œ ì•Œë ¤ì£¼ì‹œë©´ ë°”ë¡œ ë§Œë“¤ì–´ë“œë¦¬ê² ìŠµë‹ˆë‹¤.í•©ì„±ë°ì´í„° 100ê°œ ìƒì„± / ì¹´í†¡ì£¼ë¬¸ ë¹ˆë„ê°€ ê°€ì¥ ë†’ì€ ê²ƒìœ¼ë¡œ12ì›” 18ì¼ì¹´ì¹´ì˜¤í†¡ ì£¼ë¬¸ ë¹ˆë„ê°€ ê°€ì¥ ë†’ì€ í’ˆëª© ê¸°ì¤€ìœ¼ë¡œ í•©ì„± ë°ì´í„° 100ê±´ì„ ìƒì„±í•˜ê² ìŠµë‹ˆë‹¤.ì¹´ì¹´ì˜¤í†¡ ë¬¸ì ì£¼ë¬¸ ë§ì€ í’ˆëª© ì‹í’ˆ ë°˜ì°¬ ë†ì‚°ë¬¼ í†µê³„ê²°ê³¼ 10ê°œë‚´ê°€ ë§Œì•½ ì¹´í†¡ ì„ ë¬¼í•˜ê¸°ì˜ ë¶„ì„ê°€ë¼ë©´datarian.ioì„ ë¬¼í•˜ê¸°ì˜ ì‹œì‘ | ì¹´ì¹´ì˜¤kakaocorp.comì¹´ì¹´ì˜¤í†¡ ì„ ë¬¼í•˜ê¸° - kakaoì œíœ´ì•ˆë‚´kakao.comì•Œë¦¼í†¡channel.ioKADX ë†ì‹í’ˆ ë¹…ë°ì´í„° ê±°ë˜ì†Œkadx.co.krë” í¸í•œ ëª¨ë°”ì¼ ìƒí™œì˜ ì‹œì‘, ì¹´ì¹´ì˜¤í†¡ ì±„ë„ | ì¹´ì¹´ì˜¤kakaocorp.comíŒë§¤ê´€ë¦¬ | kakao business ë¹„ì¦ˆë‹ˆìŠ¤ ê°€ì´ë“œgitbook.ioì¹´ì¹´ì˜¤í†¡ ì„ ë¬¼í•˜ê¸°kakao.comì¹´ì¹´ì˜¤í†¡ ì„ ë¬¼í•˜ê¸°kakao.com"ì¼ë°˜ ì‡¼í•‘ëª°ê³¼ ë‹¤ë¥´ë„¤"â€¦'ì¹´í†¡ ì„ ë¬¼' ë‹¨ê³¨ìƒí’ˆ ë¹„ê²° ì•Œê³ ë³´ë‹ˆâ€¦ - íŒŒì´ë‚¸ì…œë‰´ìŠ¤fnnews.comì†Œìƒê³µì¸ ì¹´ì¹´ì˜¤í†¡ ì£¼ë¬¸ ë°˜ì°¬ ë†ì‚°ë¬¼ ê³¼ì¼ ì§ê±°ë˜ ê³µë™êµ¬ë§¤ê²°ê³¼ 10ê°œ
